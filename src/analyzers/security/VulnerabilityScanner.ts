/**
 * 漏洞扫描器
 * 
 * @description 扫描项目依赖的安全漏洞
 * @module analyzers/security/VulnerabilityScanner
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import type { Analyzer, Vulnerability } from '../../types';
import { fileExists, readJsonFile } from '../../utils/fileUtils';
import { AnalysisError, NetworkError } from '../../errors';
import path from 'path';

const execAsync = promisify(exec);

/**
 * 漏洞扫描结果
 */
export interface VulnerabilityResult {
  /** 漏洞列表 */
  vulnerabilities: Vulnerability[];
  /** 总数 */
  total: number;
  /** 按严重程度分组 */
  bySeverity: {
    low: number;
    moderate: number;
    high: number;
    critical: number;
  };
}

/**
 * npm audit结果格式
 */
interface NpmAuditResult {
  vulnerabilities?: Record<string, {
    name: string;
    severity: string;
    isDirect: boolean;
    via: Array<{
      title: string;
      url?: string;
      severity: string;
      cwe?: string[];
      cvss?: { score: number };
    }>;
    range: string;
  }>;
  metadata?: {
    vulnerabilities: {
      low: number;
      moderate: number;
      high: number;
      critical: number;
      total: number;
    };
  };
}

/**
 * 漏洞扫描器
 * 
 * @description 使用npm audit扫描项目依赖的安全漏洞
 * 
 * @example
 * ```typescript
 * const scanner = new VulnerabilityScanner();
 * const result = await scanner.analyze({ 
 *   projectPath: './my-project' 
 * });
 * 
 * console.log(`发现 ${result.total} 个安全漏洞`);
 * console.log(`严重漏洞: ${result.bySeverity.critical}`);
 * ```
 */
export class VulnerabilityScanner implements Analyzer {
  /**
   * 获取分析器名称
   */
  getName(): string {
    return 'VulnerabilityScanner';
  }

  /**
   * 扫描项目的安全漏洞
   * 
   * @param data - 包含项目路径的数据对象
   * @returns 漏洞扫描结果
   * @throws {AnalysisError} 当扫描失败时
   * @throws {NetworkError} 当网络请求失败时
   */
  async analyze(data: { projectPath: string }): Promise<VulnerabilityResult> {
    const { projectPath } = data;

    try {
      // 检查是否存在package.json
      const packageJsonPath = path.join(projectPath, 'package.json');
      if (!(await fileExists(packageJsonPath))) {
        console.warn('未找到package.json，跳过漏洞扫描');
        return this.getEmptyResult();
      }

      // 运行npm audit
      const auditResult = await this.runNpmAudit(projectPath);

      // 解析结果
      return this.parseAuditResult(auditResult);
    } catch (error) {
      // 网络错误
      if ((error as any).code === 'ENOTFOUND' || (error as any).code === 'ETIMEDOUT') {
        throw new NetworkError(
          '无法连接到npm registry',
          { projectPath },
          error as Error
        );
      }

      // 其他错误，返回空结果而不是抛出异常
      console.warn('漏洞扫描失败:', (error as Error).message);
      return this.getEmptyResult();
    }
  }

  /**
   * 运行npm audit命令
   * 
   * @param projectPath - 项目路径
   * @returns audit结果
   * @private
   */
  private async runNpmAudit(projectPath: string): Promise<NpmAuditResult> {
    try {
      // 使用--json参数获取JSON格式输出
      const { stdout } = await execAsync(
        'npm audit --json',
        {
          cwd: projectPath,
          timeout: 30000, // 30秒超时
        }
      );

      return JSON.parse(stdout);
    } catch (error: any) {
      // npm audit即使发现漏洞也会返回非0退出码
      // 所以我们需要检查stderr是否包含JSON
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout);
        } catch {
          // 解析失败，抛出原错误
        }
      }

      throw error;
    }
  }

  /**
   * 解析audit结果
   * 
   * @param auditResult - npm audit结果
   * @returns 漏洞扫描结果
   * @private
   */
  private parseAuditResult(auditResult: NpmAuditResult): VulnerabilityResult {
    const vulnerabilities: Vulnerability[] = [];
    const bySeverity = {
      low: 0,
      moderate: 0,
      high: 0,
      critical: 0,
    };

    if (!auditResult.vulnerabilities) {
      return {
        vulnerabilities: [],
        total: 0,
        bySeverity,
      };
    }

    // 解析每个漏洞
    for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities)) {
      // npm audit v7+格式
      if (Array.isArray(vulnData.via)) {
        for (const via of vulnData.via) {
          if (typeof via === 'object' && via.title) {
            const severity = this.normalizeSeverity(via.severity);

            vulnerabilities.push({
              package: packageName,
              version: vulnData.range,
              severity,
              title: via.title,
              description: via.title,
              recommendation: `更新到安全版本`,
              cve: via.cwe?.join(', '),
            });

            bySeverity[severity]++;
          }
        }
      }
    }

    // 使用metadata中的统计（如果有）
    if (auditResult.metadata?.vulnerabilities) {
      const meta = auditResult.metadata.vulnerabilities;
      bySeverity.low = meta.low || bySeverity.low;
      bySeverity.moderate = meta.moderate || bySeverity.moderate;
      bySeverity.high = meta.high || bySeverity.high;
      bySeverity.critical = meta.critical || bySeverity.critical;
    }

    return {
      vulnerabilities,
      total: vulnerabilities.length,
      bySeverity,
    };
  }

  /**
   * 标准化严重程度
   * 
   * @param severity - 原始严重程度
   * @returns 标准化的严重程度
   * @private
   */
  private normalizeSeverity(severity: string): 'low' | 'moderate' | 'high' | 'critical' {
    const normalized = severity.toLowerCase();

    if (['critical'].includes(normalized)) {
      return 'critical';
    }
    if (['high'].includes(normalized)) {
      return 'high';
    }
    if (['moderate', 'medium'].includes(normalized)) {
      return 'moderate';
    }

    return 'low';
  }

  /**
   * 获取空结果
   * 
   * @returns 空的漏洞扫描结果
   * @private
   */
  private getEmptyResult(): VulnerabilityResult {
    return {
      vulnerabilities: [],
      total: 0,
      bySeverity: {
        low: 0,
        moderate: 0,
        high: 0,
        critical: 0,
      },
    };
  }
}


